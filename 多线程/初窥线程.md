# 初窥线程

### 1.程序

​	定义：程序是指令和数据的集合，可以作为目标文件保存在磁盘中，或者作为段存放在内存地址空间中。

​	理解：你可以把程序当做一种静态的实体，它完成了某些功能。当计算机执行时，从磁盘上读取到主存中，完成功能的实现。而在现在的计算机系统，“程序”是并发的，“程序”这个静态的概念已经不能描述程序动态变化的过程，因此引入了“进程”。我们常说的“处理机管理”也就是“进程管理”。

### 2.进程

​	定义：是程序运行的一个具体的实例，程序总是运行在某个进程的上下文中。

​	其组成包含：程序、数据和进程控制块(PCB)。程序部分描述了进程所需要的完成的功能，属于执行时不可修改的部分。数据部分指程序执行时所需要的数据和工作区，这部分只能为一个进程所使用，是进程可以修改的部分。而进程控制块则是进程存在的唯一标志。

​	PCB组成如下：

| 信息       | 含义                                                   |
| ---------- | ------------------------------------------------------ |
| 进程标识符 | 标明系统中的各个进程                                   |
| 状态       | 说明进程当前的状态                                     |
| 位置信息   | 指明程序及数据在内存或者外存的物理地址                 |
| 控制信息   | 参数、信号量和消息等                                   |
| 队列指针   | 链接同一状态的信息                                     |
| 优先级     | 进程调度的依据                                         |
| 现场保护区 | 将处理机的现场保护到该区域以便再次调度时能继续正确运行 |

​	理解：①程序只是一组指令的有序集合，本身不具有任何运行的含义，只是一个静态的实体。而进程则是程序在某个数据集上的执行，是一个动态的实体，拥有者自己的生命周期。进程因创建而产生，因等待资源或者事件处于阻塞，又或者因为完成任务而撤销。它反映了一个程序在一定的数据集上运行的全部动态过程。

### 3.线程

​	定义：传统的进程拥有两个基本属性：①可拥有资源的独立单位，②可独立调度和分配的基本单位。由于在进程的创建、撤销和切换，系统为其付出较大的时空开销，因此在有限的系统性能限制下，进程的数量、以及进程间切换频率收到限制，系统的并发程度不是很高。引入线程，**将线程作为调度和分配的基本单位**，进程作为独立分配资源的单位，用户就可以通过创建线程而不是进程来完成任务，这减少了程序并发执行付出的时空开销，并且提高了系统性能。

​	同一进程下的线程可以共享其进程中的所有资源，因此可以避免资源的往复切换，提高了各程序的并发程度。线程基本上不拥有资源，只拥有一点运行中必不可少的一些资源如：程序计数器、一组寄存器和栈等。

​	线程的状态同进程类似，因此把线程称呼为轻型进程；传统进程称呼为重型进程。

### 4.生命周期

​	①三态模型：在多道程序系统中，进程的运行总是走走停停，在处理器上交替执行，状态总是不断发生着变化。因此进程拥有着基本的三种状态：就绪、运行、阻塞。

​		a.运行：当一个进程在处理机上运行时，就称为该进程处于运行状态。

​		b.就绪：一个进程获得了除了处理器的所有资源，一旦得到处理机就可以运行，则称该进程处于就绪状态。

​		c.阻塞：也称为等待或者睡眠状态，一个进程正在等待某一事件发生（比如IO）而暂时停止运行，这个时候即使分配该进程一个处理机，进程也无法运行，故此时称进程处于阻塞状态。

​	![3status](C:\Users\Rowan\Desktop\OneShare\imgs\thread\3status.jpg)

​	②五态模型：而实际上，进程的状态转变更为复杂，因此引入“新建”，“终止”状态则构成了五态模型。

​		a.新建：对应于进程刚刚被创建而没有被提交，并等待系统完成创建进程所有必要信息。创建进程时分为两个阶段：①为一个新进程创建必要的管理信息；②让该进程进入就绪状态。该状态可以让操作系统依据系统的性能和内存容量的限制推迟新建状态的提交。

​		b.终止：当进程完成任务或者因为异常而撤销所处于的状态。也可以分为两个阶段：①等待操作系统进行善后处理；②释放内存

### 5.Java中的线程

#### 	5.1线程创建

##### 		5.1.1 Thread类、Runnable接口

​		线程创建的目的是完成某一个具体的任务，这在Java体现为Runable接口中的run()方法，因此在创建线程是，我们的核心代码放到run方法中，而启动线程则依靠Thread.start();

​		①自定义Thread继承类（重写run()方法）

```java
public class TestThread extends Thread {//自定义类继承Thread类
	public void run() { //run()方法被称为线程体
   	 for (int i = 0; i < 10; i++) {
        System.out.println(this.getName() + ":" + i);//getName()方法是返回线程名称
   	 	}
	}

	public static void main(String[] args) {
    	TestThread thread1 = new TestThread();//创建线程对象
    	thread1.start();//启动线程
    	TestThread thread2 = new TestThread();
    	thread2.start();
	}
}
```
​			a.每个线程都是通过某个特定的Thread对象所对应的方法run( )来完成其操作的，方法run( )称为线程体。

​			b.通过调用Thread类的start()方法来启动一个线程（只是将线程由新生态转为就绪态，而不是运行态）。

​		不足：Java只支持单继承，所以当类已经继承了一个类的时候，无法再去继承Thread类，拓展性不好。因此在实际开发中，应该采用实现Runnable接口的方式来实现线程。

​		②：自定义Runnable实现类

```java
public class TestThread2 implements Runnable {//自定义类实现Runnable接口；

	public void run() {
    	for (int i = 0; i < 10; i++) {
        	System.out.println(Thread.currentThread().getName() + ":" + i);
    	}
	}
	public static void main(String[] args) {
    	//创建线程对象，把实现了Runnable接口的对象作为参数传入；
    	Thread thread1 = new Thread(new TestThread2());
    	thread1.start();//启动线程；
    	Thread thread2 = new Thread(new TestThread2());
    	thread2.start();
	}
}
```
​	note：应该注意线程的start()方法只在Thread类中，因此要通过new Thread(new TestThread2())的方式进行启动。

##### 	5.1.2 通过Callable实现多线程

​		前面两种方式有一个明显的缺陷:无法获取任务完成后的执行结果。

​		自从java 1.5之后，就提供了Callable和Future接口，通过它们就可以获取任务执行的结果。

#### 5.2线程中断与阻塞

